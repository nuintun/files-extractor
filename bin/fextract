#!/usr/bin/env node

'use strict';

// set process title
process.title = 'file extractor';

var path = require('path');
var program = require('commander');
var colors = require('colors/safe');
var pkg = require('../package.json');
var FilesExtractor = require('../');
var utils = require('../lib/utils');
var inquirer = require('inquirer');

var CWD = process.cwd();
var FILTER = ['mtime', 'ctime', 'atime', 'birthtime'];

var formatter = {
  date: function(value) {
    if (/^[+-]?\d*(\.\d*)?$/.test(value)) {
      value = parseInt(value);
    }

    return new Date(value);
  },
  dir: function(value) {
    return path.join(CWD, String(value));
  }
};

program
  .version(pkg.version)
  .description(colors.reset.cyan.bold(pkg.description))
  .option('-v, --verbose', 'show more processing logs')
  .option('-d, --dir <path>', 'set the out dir of file extractor', formatter.dir)
  .option('-s, --start <date>', 'set the start date of file extractor', formatter.date)
  .option('-e, --end <date>', 'set the end date of file extractor', formatter.date)
  .option('-f, --filter <type>', 'set the filter type file extractor')
  .option('-z, --zip', 'compress the extracted files into a zip file');

program.on('--help', function() {
  process.stdout.write(`\n  Documentation can be found at ${ colors.reset.magenta.bold(pkg.homepage) }.\n`);
});

program.parse(process.argv);

function promptDate(type, callback) {
  return {
    type: 'input',
    name: type,
    message: `Please enter ${ type } date: `,
    validate: function(value) {
      if (utils.dateIsValid(formatter.date(value))) {
        return true;
      }

      return `Oops, value "${ value }" isn't a valid date!`;
    }
  };
}

function promptFilter() {
  return {
    type: 'list',
    name: 'filter',
    message: 'Please choose filter type: ',
    choices: ['mtime', 'ctime', 'atime', 'birthtime']
  };
}

var questions = [];
var INI = FilesExtractor.loadYAML();
var INIStart = INI.start && formatter.date(INI.start);
var INIEnd = INI.end && formatter.date(INI.end);
var INIFilter = FILTER.indexOf(INI.FILTER) !== -1 ? INI.FILTER : FILTER[0];

INIStart = utils.dateIsValid(INIStart) ? INIStart : null;
INIEnd = utils.dateIsValid(INIEnd) ? INIEnd : null;

if (program.hasOwnProperty('start')) {
  if (!utils.dateIsValid(program.start)) {
    questions.push(promptDate('start'));
  }
} else {
  if (!INIStart) {
    questions.push(promptDate('start'));
  }
}

if (program.hasOwnProperty('end')) {
  if (!utils.dateIsValid(program.end)) {
    questions.push(promptDate('end'));
  }
}

if (program.hasOwnProperty('filter')) {
  if (FILTER.indexOf(program.filter) === -1) {
    questions.push(promptFilter());
  }
}

if (questions.length) {
  inquirer
    .prompt(questions)
    .then(function(input) {
      var verbose = Boolean(program.verbose || INI.verbose);
      var dir = program.dir || formatter.dir(INI.dir || '.extract');
      var start = input.start ? formatter.date(input.start) : (program.start || INIStart);
      var end = input.end ? formatter.date(input.end) : (program.end || (INIEnd ? INIEnd : new Date()));
      var zip = Boolean(program.zip || INI.zip);
      var filter = input.filter || program.filter || INIFilter;

      console.log(JSON.stringify({ verbose, dir, start, end, zip, filter }, null, 2));
    }).catch(function(error) {
      process.stderr.write(error);
    });
} else {
  process.nextTick(function() {
    var verbose = Boolean(program.verbose || INI.verbose);
    var dir = program.dir || formatter.dir(INI.dir || '.extract');
    var start = program.start ? program.start : INIStart;
    var end = program.end ? program.end : (INIEnd || new Date());
    var zip = Boolean(program.zip || INI.zip);
    var filter = program.filter || INIFilter;

    console.log(JSON.stringify({ verbose, dir, start, end, zip, filter }, null, 2));
  });
}
