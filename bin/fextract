#!/usr/bin/env node

'use strict';

// set process title
process.title = 'files extractor';

const cluster = require('cluster');

if (cluster.isMaster) {
  cluster.setupMaster({ silent: false });

  const UI = require('../lib/ui');
  const program = require('commander');
  const pkg = require('../package.json');
  const utils = require('../lib/utils');
  const inquirer = require('inquirer');
  const CONST = require('../lib/const');
  const formatter = require('../lib/formatter');
  const validator = require('../lib/validator');

  const parseDate = utils.parseDate;
  const parseTypes = utils.parseTypes;
  const valueInvalid = utils.valueInvalid;

  program
    .version(pkg.version)
    .description(utils.color(pkg.description, 'cyan', false, true))
    .option('-d, --dot', 'extract dot files')
    .option('-f, --files <files>', 'set the files of extract')
    .option('-o, --output <path>', 'set the output dir of extract')
    .option('-s, --start <date>', 'set the start date of extract', parseDate)
    .option('-e, --end <date>', 'set the end date of extract', parseDate)
    .option('-t, --types <type,...>', `set the filter types[${ CONST.FILTER_TYPES.join(', ') }] of extract`, parseTypes);

  program.on('--help', function() {
    process.stdout.write(`\n\n  Documentation can be found at ${ utils.color(pkg.homepage, 'magenta', false, true) }.\n`);
  });

  program.parse(process.argv);

  let prompt = [];
  let yaml = utils.loadYAML(CONST.YAML_SRC) || {};

  function promptInput(name, parser) {
    return {
      name: name,
      type: 'input',
      message: `Please input ${ name }: `,
      validate: function(value) {
        if (validator[name](parser ? parser(value) : value)) {
          return true;
        }

        return `Oops, value ${ JSON.stringify(value) } is invalid!`;
      }
    };
  }

  function promptCheckbox(name, choices, required) {
    return {
      name: name,
      type: 'checkbox',
      message: `Please choose ${ name }: `,
      choices: choices,
      validate: function(value) {
        if (required && value.length < 1) {
          return 'Oops, you must choose at least one item!';
        }

        return true;
      }
    };
  }

  CONST.OPTIONS_KEYS.forEach(function(key) {
    let value = program[key];
    let yamlValue = yaml[key];
    let format = formatter[key];
    let validate = validator[key];
    let hasOwnKey = program.hasOwnProperty(key);
    let yamlHasOwnKey = yaml.hasOwnProperty(key);

    function save(value) {
      program[key] = value;
    }

    switch (key) {
      case 'start':
      case 'end':
        if (hasOwnKey) {
          if (!validate(value)) {
            valueInvalid(key);
            prompt.push(promptInput(key, parseDate));
          }
        } else if (yamlHasOwnKey) {
          yamlValue = parseDate(yamlValue);

          if (validate(yamlValue)) {
            save(yamlValue);
          } else {
            valueInvalid(key, CONST.YAML);
            prompt.push(promptInput(key, parseDate));
          }
        } else {
          if (key === 'start') {
            prompt.push(promptInput(key, parseDate));
          } else {
            save(format(value));
          }
        }
        break;
      case 'types':
        if (hasOwnKey) {
          if (!validate(value)) {
            valueInvalid(key);
            prompt.push(promptCheckbox(key, CONST.FILTER_TYPES, true));
          }
        } else if (yamlHasOwnKey) {
          yamlValue = parseTypes(yamlValue);

          if (validate(yamlValue)) {
            save(yamlValue);
          } else {
            valueInvalid(key, CONST.YAML);
            prompt.push(promptCheckbox(key, CONST.FILTER_TYPES, true));
          }
        } else {
          save(format(value));
        }
        break;
      default:
        if (hasOwnKey) {
          if (!validate(value)) {
            valueInvalid(key);
            prompt.push(promptInput(key));
          }
        } else if (yamlHasOwnKey) {
          if (validate(yamlValue)) {
            save(yamlValue);
          } else {
            valueInvalid(key, CONST.YAML);
            prompt.push(promptInput(key));
          }
        } else {
          save(format(value));
        }
    }
  });

  function bootstrap() {
    let options = {};

    CONST.OPTIONS_KEYS.forEach(function(key) {
      options[key] = program[key];
    });

    return {
      status: CONST.STATUS.BOOTSTRAP,
      data: options
    };
  }

  const worker = cluster.fork();

  if (prompt.length) {
    inquirer
      .prompt(prompt)
      .then(function(input) {
        Object
          .keys(input)
          .forEach(function(key) {
            let value = input[key];
            let format = formatter[key];

            program[key] = format(value);
          });

        worker.send(bootstrap());
      })
      .catch(function(exception) {
        utils.error(exception);
      });
  } else {
    worker.send(bootstrap());
  }

  new UI(worker);
} else {
  require('../lib/thread');
}
