#!/usr/bin/env node

'use strict';

// set process title
process.title = 'files extractor';

const cluster = require('cluster');

if (cluster.isMaster) {
  let chalk = require('chalk');
  let UI = require('../lib/ui');
  let program = require('commander');
  let pkg = require('../package.json');
  let utils = require('../lib/utils');
  let inquirer = require('inquirer');
  let CONST = require('../lib/const');
  let formatter = require('../lib/formatter');
  let validator = require('../lib/validator');

  cluster.setupMaster({ silent: false });

  let worker = cluster.fork();

  new UI(worker);

  program
    .version(pkg.version)
    .description(chalk.reset.cyan.bold(pkg.description))
    .option('-d, --dot', 'extract dot files')
    .option('-f, --files <files>', 'set the files of extract')
    .option('-o, --output <path>', 'set the output dir of extract')
    .option('-s, --start <date>', 'set the start date of extract', utils.parseDate)
    .option('-e, --end <date>', 'set the end date of extract', utils.parseDate)
    .option('-t, --types <type,...>', `set the filter types[${ CONST.FILTER_TYPES.join(', ') }] of extract`, utils.parseTypes);

  program.on('--help', function() {
    process.stdout.write(`\n\n  Documentation can be found at ${ chalk.reset.magenta.bold(pkg.homepage) }.\n`);
  });

  program.parse(process.argv);

  let prompt = [];
  let yaml = utils.loadYAML(CONST.YAML_SRC) || {};

  function promptInput(name, parser) {
    return {
      name: name,
      type: 'input',
      message: `Please input ${ name }: `,
      validate: function(value) {
        if (validator[name](parser ? parser(value) : value)) {
          return true;
        }

        return `Oops, value ${ JSON.stringify(value) } is invalid!`;
      }
    };
  }

  function promptCheckbox(name, choices, required) {
    return {
      name: name,
      type: 'checkbox',
      message: `Please choose ${ name }: `,
      choices: choices,
      validate: function(value) {
        if (required && value.length < 1) {
          return 'Oops, you must choose at least one item!';
        }

        return true;
      }
    };
  }

  function valueInvalid(key, yaml) {
    let ref = yaml ? ` at ${ CONST.YAML }` : '';

    utils.error(`Option ${ key }'s value is invalid${ ref }!`);
  }

  CONST.OPTIONS_KEYS.forEach(function(key) {
    let value = program[key];
    let yamlValue = yaml[key];
    let format = formatter[key];
    let validate = validator[key];
    let hasOwnKey = program.hasOwnProperty(key);
    let yamlHasOwnKey = yaml.hasOwnProperty(key);

    switch (key) {
      case 'start':
      case 'end':
        if (hasOwnKey) {
          if (!validate(value)) {
            valueInvalid(key);
            prompt.push(promptInput(key, utils.parseDate));
          }
        } else {
          if (yamlHasOwnKey) {
            yamlValue = utils.parseDate(yamlValue);

            if (!validate(yamlValue)) {
              valueInvalid(key, true);
              prompt.push(promptInput(key, utils.parseDate));
            }
          } else {
            if (key === 'start') {
              prompt.push(promptInput(key, utils.parseDate));
            } else {
              program[key] = format(value);
            }
          }
        }
        break;
      case 'types':
        if (hasOwnKey) {
          if (!validate(value)) {
            valueInvalid(key);
            prompt.push(promptCheckbox(key, CONST.FILTER_TYPES, true));
          }
        } else {
          if (yamlHasOwnKey) {
            yamlValue = utils.parseTypes(yamlValue);

            if (!validate(yamlValue)) {
              valueInvalid(key, true);
              prompt.push(promptCheckbox(key, CONST.FILTER_TYPES, true));
            }
          } else {
            program[key] = format(value);
          }
        }
        break;
      default:
        if (hasOwnKey) {
          if (!validate(value)) {
            valueInvalid(key);
            prompt.push(promptInput(key));
          }
        } else {
          if (yamlHasOwnKey) {
            if (!validate(yamlValue)) {
              valueInvalid(key, true);
              prompt.push(promptInput(key));
            }
          } else {
            program[key] = format(value);
          }
        }
    }
  });

  function bootstrap() {
    let options = {};

    CONST.OPTIONS_KEYS.forEach(function(key) {
      options[key] = program[key];
    });

    return {
      status: CONST.STATUS.BOOTSTRAP,
      data: options
    };
  }

  if (prompt.length) {
    inquirer
      .prompt(prompt)
      .then(function(input) {
        Object
          .keys(input)
          .forEach(function(key) {
            let value = input[key];
            let format = formatter[key];

            program[key] = format(value);
          });

        worker.send(bootstrap());
      })
      .catch(function(exception) {
        utils.error(exception);
      });
  } else {
    worker.send(bootstrap());
  }
} else {
  require('../lib/thread');
}
